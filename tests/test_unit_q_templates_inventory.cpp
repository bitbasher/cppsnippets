/**
 * @file test_templates_inventory.cpp
 * @brief Phase 4 tests for TemplatesInventory class
 * 
 * Tests QHash-based storage with hierarchical keys for templates.
 * Templates are .json files (not .scad), no attachments, no categories.
 */

#include <QtTest/QtTest>
#include <QDir>
#include <QDirListing>
#include <QSettings>

#include "resourceInventory/TemplatesInventory.hpp"
#include "resourceInventory/resourceItem.hpp"

using namespace resourceInventory;

class TemplatesInventoryTest : public QObject {
    Q_OBJECT

private:
    QString testDataPath;
    
private slots:
    void initTestCase() {
        // Hardwired path to testFileStructure templates
        testDataPath = "D:/repositories/cppsnippets/cppsnippets/testFileStructure/inst/OpenSCAD/templates";
        QVERIFY2(QDir(testDataPath).exists(), qPrintable(QString("testFileStructure templates not found at: %1").arg(testDataPath)));
    }

// ============================================================================
// Phase 4: TemplatesInventory Tests
// ============================================================================

    void addTemplateWithHierarchicalKey() {
        TemplatesInventory inventory;
        
        // Create ResourceLocation for test data
        platformInfo::ResourceLocation location(testDataPath, resourceMetadata::ResourceTier::Installation);
        
        // Scan templates folder for .json files (skip bad test files)
        for (const auto& entry : QDirListing(testDataPath, {"*.json"})) {
            if (entry.isFile() && !entry.fileName().contains("bad")) {
                QVERIFY(inventory.addTemplate(entry, location));
            }
        }
        
        QVERIFY2(inventory.count() > 0, "Should find valid .json templates in testFileStructure");
        
        // Verify hierarchical key format (tier-name)
        QList<QVariant> all = inventory.getAll();
        if (all.size() > 0) {
            QVariant var = all.first();
            QVERIFY(var.canConvert<ResourceTemplate>());
            
            ResourceTemplate tmpl = var.value<ResourceTemplate>();
            QVERIFY(!tmpl.displayName().isEmpty());
        }
    }

    void differentTiersSameFile() {
        TemplatesInventory inventory;
        platformInfo::ResourceLocation installLocation(testDataPath, ResourceTier::Installation);
        platformInfo::ResourceLocation userLocation(testDataPath, ResourceTier::User);
        
        QString templatePath;
        for (const auto& entry : QDirListing(testDataPath, {"*.json"})) {
            if (entry.isFile() && !entry.fileName().contains("bad")) {
                templatePath = entry.filePath();
                
                // Add same file with different tiers
                QVERIFY(inventory.addTemplate(entry, installLocation));
                QVERIFY(inventory.addTemplate(entry, userLocation));
                
                break;
            }
        }
        
        if (!templatePath.isEmpty()) {
            // Should have 2 entries (different keys: installation-name, user-name)
            QCOMPARE(inventory.count(), 2);
        }
    }

    void duplicateKeyRejected() {
        TemplatesInventory inventory;
        platformInfo::ResourceLocation location(testDataPath, ResourceTier::Installation);
        
        // ResourceIndexer increments counter on each call, so adding same file twice
        // creates two different IDs. This test verifies both adds succeed with different IDs.
        bool foundValid = false;
        int addedCount = 0;
        
        for (const auto& entry : QDirListing(testDataPath, {"*.json"})) {
            if (entry.isFile() && !entry.fileName().contains("bad")) {
                // First add succeeds
                if (inventory.addTemplate(entry, location)) {
                    addedCount++;
                }
                // Second add also succeeds (different ID generated by ResourceIndexer)
                if (inventory.addTemplate(entry, location)) {
                    addedCount++;
                }
                foundValid = true;
                break;
            }
        }
        
        QVERIFY2(foundValid, "No valid templates found for duplicate test");
        // Both additions should succeed with different ResourceIndexer IDs
        QCOMPARE(inventory.count(), 2);
    }

    void getAll() {
        TemplatesInventory inventory;
        platformInfo::ResourceLocation location(testDataPath, ResourceTier::Installation);
        
        int addedCount = 0;
        for (const auto& entry : QDirListing(testDataPath, {"*.json"})) {
            if (entry.isFile() && !entry.fileName().contains("bad")) {
                if (inventory.addTemplate(entry, location)) {
                    addedCount++;
                }
            }
        }
        
        QList<QVariant> all = inventory.getAll();
        QCOMPARE(all.size(), addedCount);
        QCOMPARE(inventory.count(), addedCount);
    }

    void addFolderWithTemplates() {
        TemplatesInventory inventory;
        platformInfo::ResourceLocation location(testDataPath, ResourceTier::Installation);
        
        // Create a DirEntry from the testDataPath by listing parent
        int added = 0;
        QDir dir(testDataPath);
        if (dir.exists()) {
            // Use QDirListing to get a proper DirEntry
            for (const auto& entry : QDirListing(testDataPath)) {
                if (entry.isFile() && entry.fileName().endsWith(".json") && !entry.fileName().contains("bad")) {
                    if (inventory.addTemplate(entry, location)) {
                        added++;
                    }
                }
            }
        }
        
        QVERIFY(added >= 0);
        QCOMPARE(inventory.count(), added);
    }

    void clear() {
        TemplatesInventory inventory;
        platformInfo::ResourceLocation location(testDataPath, ResourceTier::Installation);
        
        int validFilesFound = 0;
        for (const auto& entry : QDirListing(testDataPath, {"*.json"})) {
            if (entry.isFile() && !entry.fileName().contains("bad")) {
                validFilesFound++;
                QVERIFY2(inventory.addTemplate(entry, location), 
                         qPrintable(QString("Failed to add valid template: %1").arg(entry.fileName())));
            }
        }
        
        if (validFilesFound == 0) {
            QSKIP("No valid templates found to test clear()");
        }
        
        QVERIFY2(inventory.count() > 0, "Inventory should contain templates before clear()");
        inventory.clear();
        QCOMPARE(inventory.count(), 0);
        QVERIFY(inventory.getAll().isEmpty());
    }

    void jsonContentStructure() {
        TemplatesInventory inventory;
        platformInfo::ResourceLocation location(testDataPath, ResourceTier::Installation);
        
        // Add a valid template and get its actual key
        QString templateKey;
        for (const auto& entry : QDirListing(testDataPath, {"*.json"})) {
            if (entry.isFile() && !entry.fileName().contains("bad")) {
                QVERIFY(inventory.addTemplate(entry, location));
                
                // Get the actual key from inventory
                QList<QVariant> all = inventory.getAll();
                if (!all.isEmpty()) {
                    ResourceTemplate tmpl = all.first().value<ResourceTemplate>();
                    templateKey = tmpl.uniqueID();
                }
                break;
            }
        }
        
        if (templateKey.isEmpty()) {
            QSKIP("No valid .json templates found for structure test");
        }
        
        // Get JSON content
        QJsonObject json = inventory.getJsonContent(templateKey);
        QVERIFY(!json.isEmpty());
        
        // VS Code snippet format should have "body" and "prefix"
        // (Actual structure depends on your .json files)
        // This test verifies JSON is parsed, structure validation is separate
        QVERIFY(json.contains("body") || json.contains("prefix") || json.contains("description"));
    }

// ============================================================================
// Bad JSON Detection Tests
// ============================================================================

    void rejectsBadJsonWithUnterminatedArray() {
        TemplatesInventory inventory;
        platformInfo::ResourceLocation location(testDataPath, ResourceTier::Installation);
        
        // Find bad_array file using pattern
        bool foundBadFile = false;
        for (const auto& entry : QDirListing(testDataPath, {"*bad*.json"})) {
            if (entry.isFile() && entry.fileName().contains("array")) {
                foundBadFile = true;
                // Should reject bad JSON
                QVERIFY2(!inventory.addTemplate(entry, location),
                         qPrintable(QString("Bad JSON file should be rejected: %1").arg(entry.fileName())));
                
                // Inventory should remain empty
                QCOMPARE(inventory.count(), 0);
                break;
            }
        }
        
        if (!foundBadFile) {
            QSKIP("Bad JSON test file (bad_array) not found");
        }
    }

    void rejectsBadJsonWithMissingComma() {
        TemplatesInventory inventory;
        platformInfo::ResourceLocation location(testDataPath, ResourceTier::Installation);
        
        // Find bad_comma file using pattern
        bool foundBadFile = false;
        for (const auto& entry : QDirListing(testDataPath, {"*bad*.json"})) {
            if (entry.isFile() && entry.fileName().contains("comma")) {
                foundBadFile = true;
                QVERIFY2(!inventory.addTemplate(entry, location),
                         qPrintable(QString("Bad JSON file should be rejected: %1").arg(entry.fileName())));
                QCOMPARE(inventory.count(), 0);
                break;
            }
        }
        
        if (!foundBadFile) {
            QSKIP("Bad JSON test file (bad_comma) not found");
        }
    }

    void rejectsBadJsonWithInvalidSyntax() {
        TemplatesInventory inventory;
        platformInfo::ResourceLocation location(testDataPath, ResourceTier::Installation);
        
        // Find bad_template file using pattern
        bool foundBadFile = false;
        for (const auto& entry : QDirListing(testDataPath, {"*bad*.json"})) {
            if (entry.isFile() && entry.fileName().contains("template")) {
                foundBadFile = true;
                QVERIFY2(!inventory.addTemplate(entry, location),
                         qPrintable(QString("Bad JSON file should be rejected: %1").arg(entry.fileName())));
                QCOMPARE(inventory.count(), 0);
                break;
            }
        }
        
        if (!foundBadFile) {
            QSKIP("Bad JSON test file (bad_template) not found");
        }
    }

    void validTemplatesAddedDespiteBadOnes() {
        TemplatesInventory inventory;
        platformInfo::ResourceLocation location(testDataPath, ResourceTier::Installation);
        
        int validCount = 0;
        int badCount = 0;
        
        // Try to add all templates (good and bad)
        for (const auto& entry : QDirListing(testDataPath, {"*.json"})) {
            if (entry.isFile()) {
                if (inventory.addTemplate(entry, location)) {
                    validCount++;
                } else {
                    badCount++;
                }
            }
        }
        
        // Should have added some valid templates
        QVERIFY2(validCount > 0, "Expected at least one valid template");
        
        // Should have rejected bad templates
        QVERIFY2(badCount >= 3, "Expected at least 3 bad templates (inst_bad_*.json)");
        
        // Inventory count should match valid templates only
        QCOMPARE(inventory.count(), validCount);
    }
};

QTEST_GUILESS_MAIN(TemplatesInventoryTest)
#include "test_unit_q_templates_inventory.moc"
