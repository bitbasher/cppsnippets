# Phase 2A: DiscoveryScanner Detailed Implementation

**Date:** January 6, 2026  
**Updated:** January 10, 2026 - Post Namespace Reorganization  
**Status:** ‚ö†Ô∏è SUPERSEDED - See 2026-01-10-phase2a-revised-after-reorganization.md  
**Author:** GitHub Copilot (Claude Sonnet 4.5)  
**Phase:** 2A - Discovery Scanner Only (Minimal Scope)

---

## ‚ö†Ô∏è IMPORTANT: This Document is Superseded

**This design was created before the namespace reorganization.**

**Please refer to the updated design document:**  
üìÑ **[2026-01-10-phase2a-revised-after-reorganization.md](2026-01-10-phase2a-revised-after-reorganization.md)**

**Key Changes in Revised Version:**
- ‚úÖ Reflects completed namespace reorganization (pathDiscovery, resourceMetadata, resourceDiscovery)
- ‚úÖ Updated to use current 12-path system from pathDiscovery::ResourcePaths
- ‚úÖ ResourceLocation includes resourceFolders list (which folders were found)
- ‚úÖ Display name generation rules refined for all tiers
- ‚úÖ Integration examples updated with correct namespaces
- ‚úÖ Test strategy expanded to 30 tests across 6 categories
- ‚úÖ Clean design based on actual working path discovery system

**This document is kept for historical reference only.**

---

## üîÑ Update Notes (Jan 10, 2026)

**What Changed Since This Document Was Written:**

1. ‚úÖ **Namespace reorganization completed** (Steps 1-7 from 2026-01-09 roadmap)
   - `resourceMetadata` namespace created with ResourceTier, ResourceType definitions
   - `pathDiscovery` namespace contains PathElement and ResourcePaths
   - `resourceInventory` namespace renamed from `resInventory`

2. ‚úÖ **Path discovery system enhanced**
   - Added deduplication using QSet<QString>
   - Added QStandardPaths::DocumentsLocation to User tier
   - Added QCoreApplication::applicationDirPath() for exe location detection
   - Moved user-designated paths to User tier (correct semantics)
   - Debug traces removed (clean production-ready code)

3. ‚úÖ **Test infrastructure in place**
   - test_path_discovery.cpp diagnostic tool validates path processing
   - Shows 12 qualified paths with detailed transformations
   - Confirmed: 68 tests passing, 13 failing (unrelated testFileStructure issue)

---

## Design Philosophy

**Keep It Simple:** This phase implements ONLY DiscoveryScanner. No LocationScanner, no resource scanning, no inventory. Just path validation and location discovery.

**Test-Driven:** Tests written first, implementation follows.

**Clear Boundaries:** Input is `QList&lt;PathElement&gt;`, output is `QList&lt;ResourceLocation&gt;`.

---

## Scope: What Phase 2A Does

‚úÖ **In Scope:**

- Take list of paths from ResourcePaths
- Check each path exists
- Check each path is readable
- Detect if path contains any resource folders
- Create ResourceLocation for valid, populated paths
- Return list of validated locations

&gt;&gt;NEW there is a mock file system loaded with a selection of resource files, including some that should be ignored if the code is working correclty.
D:\repositories\cppsnippets\cppsnippets\testFileStructure

‚ùå **Out of Scope:**

- Resource file scanning (Phase 2B)
- Inventory population (Phase 2B)
- GUI integration (Phase 5)
- QSettings persistence (handled elsewhere)
- LocationScanner (Phase 2B)
- manual enable/disable of locations

---

# Discovered Specifications

&gt;&gt;NEW

i have been rereading old chats to refresh myself on design intent, and also found some interesting things in the docs on QDir

a revision of the stage 1 work is needed

we start by considering Qt features that support discovery operations in a file space.

the QDir class has

- QDir QDir::home()
- QString QDir::homePath()
- toNativeSeparators()

methods to know the user's home direcotry without using env vars.
read this page for full description of QDir https://doc.qt.io/qt-6/qdir.html

but in fact .. all of the locations we would like to search are available using another Qt class : QStandarPaths

In the following table :

- RO means Read-Only
- USER is the users ID

## QStandardPaths class (redacted)

https://doc.qt.io/qt-6/qstandardpaths.html

| Path type | Enum Value | macOS | Windows | Linux/Posix | Description |
|----|---|-------|-----|-----|--------------------|
| DocumentsLocation | 1 | "~/Documents" | "C:/Users/&lt;USER&gt;/Documents" | "~/Documents"| Returns the directory containing user document files. This is a generic value. The returned path is never empty |
| FontsLocation | 2 | "/System/Library/Fonts" (RO) | "C:/Windows/Fonts" (RO) | "~/.fonts": "~/.local/share/fonts": "/usr/local/share/fonts": "/usr/share/fonts"|
| ApplicationsLocation | 3 | "/Applications" (RO) | "C:/Users&lt;USER&gt;/AppData/Roaming/Microsoft/Windows/Start Menu/Programs" | "~/.local/share/applications": "/usr/local/share/applications": "/usr/share/applications"| Returns the directory containing the user applications as either executables, application bundles, links, or shortcuts |
| TempLocation | 7 | randomly generated by the OS | "C:/Users&lt;USER&gt;/AppData/Local/Temp" | "/tmp"|
| HomeLocation | 8 | "~" | "C:/Users/&lt;USER&gt;" | "~"| Returns the user's home directory (the same as QDir::homePath()). On Unix systems, this is equal to the HOME environment variable. This value might be generic or application-specific, but the returned path is never empty. |
| AppLocalDataLocation | 9 | "~/Library/Application Support/&lt;APPNAME&gt;": "/Library/Application Support/&lt;APPNAME&gt;": "&lt;APPDIR&gt;/../Resources" | "C:/Users/&lt;USER&gt;/AppData/Local/&lt;APPNAME&gt;"; "C:/ProgramData/&lt;APPNAME&gt;";"&lt;APPDIR&gt;";"&lt;APPDIR&gt;/data"; "&lt;APPDIR&gt;/data/&lt;APPNAME&gt;" | "~/.local/share/&lt;APPNAME&gt;": "/usr/local/share/&lt;APPNAME&gt;": "/usr/share/&lt;APPNAME&gt;"| Returns the local settings path on the Windows operating system. On all other platforms, it returns the same value as AppDataLocation |
| GenericDataLocation | 11 | "~/Library/Application Support", "/Library/Application Support" | "C:/Users/&lt;USER&gt;/AppData/Local"; "C:/ProgramData", "&lt;APPDIR&gt;"; "&lt;APPDIR&gt;/data" | "~/.local/share","/usr/local/share","/usr/share"| Returns a directory location where persistent data shared across applications can be stored. This is a generic value. The returned path is never empty. |
| ConfigLocation | 13 | "~/Library/Preferences", "&lt;APPDIR&gt;" | "C:/Users/&lt;USER&gt; /AppData/Local/&lt;APPNAME&gt;"; "C:/ProgramData/&lt;APPNAME&gt;", "&lt;APPDIR&gt;", "&lt;APPDIR&gt;" | "~/.config": "/etc/xdg"| Returns a directory location where user-specific configuration files should be written. This may be either a generic value or application-specific, and the returned path is never empty. |
| DownloadLocation | 14 | "~/Downloads" | "C:/Users/&lt;USER&gt;/Downloads" | "~/Downloads"|
| AppDataLocation | 17 | "~/Library/Application Support/&lt;APPNAME&gt;": "/Library/Application Support/&lt;APPNAME&gt;". "&lt;APPDIR&gt;/../Resources" | "C:/Users/&lt;USER&gt;/AppData/Roaming/&lt;APPNAME&gt;"; "C:/ProgramData/&lt;APPNAME&gt;"; "&lt;APPDIR&gt;", "&lt;APPDIR&gt;/data", "&lt;APPDIR&gt;/data/&lt;APPNAME&gt;" | "~/.local/share/&lt;APPNAME&gt;": "/usr/local/share/&lt;APPNAME&gt;": "/usr/share/&lt;APPNAME&gt;"| Returns a directory location where persistent application data can be stored. This is an application-specific directory. The returned path is never empty. On the Windows operating system, this returns the roaming path. |
| AppConfigLocation | 18 | "~/Library/Preferences/&lt;APPNAME&gt;", "&lt;APPDIR&gt;" | "C:/Users/&lt;USER&gt;/AppData/Local/&lt;APPNAME&gt;"; "C:/ProgramData/&lt;APPNAME&gt;", "&lt;APPDIR&gt;" | "~/.config/&lt;APPNAME&gt;": "/etc/xdg/&lt;APPNAME&gt;", "&lt;APPDIR&gt;"| Returns a directory location where user-specific configuration files should be written. This is an application-specific directory, and the returned path is never empty |
| PublicShareLocation | 19 | "~/Public" | "C:/Users/Public" | "~/Public"| Returns a directory location where user-specific publicly shared files and directories can be stored. This is a generic value. Note that the returned path may be empty if the system has no concept of a publicly shared location |
| TemplatesLocation | 20 | "~/Templates" | "C:/Users/&lt;USER&gt;/AppData/Roaming/Microsoft/Windows/Templates" | "~/Templates"| Returns a directory location where user-specific template files can be stored. This is a generic value. Note that the returned path may be empty if the system has no concept of a templates location |
  


## Installation Tier

The folder that the app is running from will normally be an installation, or a repo clone, but it could be a build/bin/Debug folder if a developer is working on it.

we can tell that it is in a standard installation folder using the list we get from QStandardPaths

| Path type | Enum Value | macOS | Windows | Linux/Posix | Description |
|----|---|-------|-----|-----|--------------------|
| ApplicationsLocation | 3 | "/Applications" (RO) | "C:/Users&lt;USER&gt;/AppData/Roaming/Microsoft/Windows/Start Menu/Programs" | "~/.local/share/applications": "/usr/local/share/applications": "/usr/share/applications"| Returns the directory containing the user applications as either executables, application bundles, links, or shortcuts |

use the getCurrentExecutableDirPath() to know the folder of the running app

but it should NOT be checked for a sibling location because :

  1. as a special case installation it is doubtfull that a sibling installation. There is a chance that folder next to that of the running app might look like a sibling but is not - best to avoid false positives
  2. if a sibling location is wanted the user (likely a developer) can add it as a user defined Location

so before we start processing the default path list
use the getCurrentExecutableDirPath() to know the folder of the running app.

QString runningAppDirName = getCurrentExecutablePath();
QDir runningAppDir = QDir(runningAppDirName);

then:

```text
if the appNameInfo::suffix is not empty
   and the runningAppDirName ends in the suffix ( with its wrapper of " (xxx)" )
Then
    add runningAppDir to the discovery path list
Else
   there is a mismatch - flag it was a warning and do not add it to discovery 
```

## User Tier



&gt;&gt;NEW
we do not have the correct information in the discoveryPaths to make the DisplayName that we need for the resourceLocation class

We do not want to use the full path names for a location, they are distracting so we need more compact titles for them.

We need to add this featuire into the ResourcePaths where we do have the needed base info.

**Rules for making the Location displayName:**

1. Install Tier - the app or sibling name
2. Machine Tier - the first part of the path
3. User Tier - extract from the path

Details: Install tier
This must be at least the entry for the running app 

```cpp
QString appDir = 
   platformInfo::PlatformInfo::getCurrentExecutableDirPath();
QDir dir(appDir);
```

no pseudocode:
if dir./basename().toLower() == 

// Build full path to a sibling file
QString configPath = dir.filePath("config.json");

Details: Machine tier

The first part of the path, like "C:\ProductData", fully informs the user about the location

Details: User tier

removing the home directory prefix and the folder name "openscad/templates" and the template filename

so C:/Users/Jeff/AppData/Local/OpenSCAD/templates/translate.json
would be shown as AppData/Local

3 the source field in the editing section is filled with the full pathname of the template .. not the source field content

User: the shorted name should be a method on the class that either takes an argument to know the tier, or get the teir from the resource item, and does not modify the full pathname.
The tier input is necessary as the extraction rules will be different for each tier




## Input/Output Specification

### Input

```cpp
struct PathElement {
    ResourceTier tier;
    QString path;
};

// From ResourcePaths::qualifiedSearchPaths()
QList&lt;PathElement&gt; discoveryPaths;
```

**Example Input:**

the elements of the ilst will never be empty .. it starts as a const QStingList defined in the code and any resource folders added by the user will be checked and only added if they contain resources.

```cpp
const QList&lt;PathElement&gt; discoveryPaths = {
    {ResourceTier::Installation, "C:/Program Files/OpenSCAD/"},
    {ResourceTier::Installation, "C:/Program Files/OpenSCAD (Nightly)/"},
    {ResourceTier::Machine, "C:/ProgramData/OpenSCAD/"},
    {ResourceTier::User, "C:/Users/Jeff/Documents/OpenSCAD/"},
    {ResourceTier::User, "C:/Users/Jeff/AppData/Roaming/OpenSCAD/"}
}
```

### Operation

Each entry in the discovery list is a folder named for the application, in our case "scadtemplate", or "scadTemplate", or even "scadtemplates" (plural),  but will eventually be "openscad" or "OpenSCAD" etc.

If the folder exists, but is not readable, log a warning and move on.

Else scan for sub-folders named for each of the resource types in turn
   if there are none then 
      log an error and move on.
   else
      instantiate a resourceLocation object
        path = discoveryPath + resTypeFolderName
        tier = discoveryTier
        displayName = 




### Output

```cpp
struct ResourceLocation {
    QString path;           // Absolute filesystem path
    ResourceTier tier;      // From PathElement
    QString displayName;    // Human-readable (e.g., "User - Documents")
    QDir::filters access;   // copy of the QDir::Filters from Location
    
    // Constructor for convenience
    ResourceLocation(const QString& p, ResourceTier t,
        const QString& dn, QDir::filters perms)
        : path(p), tier(t), displayName(dn), access(perms) {}
};

// Only paths that exist AND contain resource folders
QList&lt;ResourceLocation&gt; validatedLocations;
```

**Example Output:**

```cpp
{
    {"C:/Program Files/OpenSCAD/", Installation, "Installation - OpenSCAD", false},
    {"C:/Users/Jeff/Documents/OpenSCAD/", User, "User - Documents", true},
    {"C:/Users/Jeff/AppData/Roaming/OpenSCAD/", User, "User - AppData", true}
}
```


**Qt Tech for Directories:**

enum QDir::Filter
flags QDir::Filters

This enum describes the filtering options available to QDir; e.g. for entryList() and entryInfoList(). The filter value is specified by combining values from the following list using the bitwise OR operator:          

| Constant | Value | Description |
|----------|-------|-------------|
QDir::Dirs | 0x001 | List directories that match the filters.|
QDir::AllDirs | 0x400 | List all directories; i.e. don't apply the filters to directory names.|
QDir::Files | 0x002 | List files.|
QDir::Drives | 0x004 | List disk drives (ignored under Unix).|
QDir::NoSymLinks | 0x008 | Do not list symbolic links (ignored by operating systems that don't support symbolic links).|
QDir::NoDotAndDotDot | NoDot--NoDotDot | Do not list the special entries "." and "..".|
QDir::NoDot | 0x2000 | Do not list the special entry ".".
QDir::NoDotDot | 0x4000 | Do not list the special entry "..".
QDir::AllEntries | Dirs-Files-Drives | List directories, files, drives and symlinks (this does not list broken symlinks unless you specify System).|
QDir::Readable | 0x010 | List files for which the application has read access. The Readable value needs to be combined with Dirs or Files.|
QDir::Writable | 0x020 | List files for which the application has write access. The Writable value needs to be combined with Dirs or Files.|
QDir::Executable | 0x040 | List files for which the application has execute access. The Executable value needs to be combined with Dirs or Files.|
QDir::Modified | 0x080 | Only list files that have been modified (ignored on Unix).|
QDir::Hidden | 0x100 | List hidden files (on Unix, files starting with a ".").|
QDir::System | 0x200 | List system files (on Unix, FIFOs, sockets and device files are included; on Windows, .lnk files are included)|
QDir::CaseSensitive | 0x800 | The filter should be case sensitive.|

---

## Detailed Design

### File Structure

```
src/
‚îú‚îÄ‚îÄ resInventory/
‚îÇ   ‚îú‚îÄ‚îÄ discoveryScanner.hpp    (new)
‚îÇ   ‚îú‚îÄ‚îÄ discoveryScanner.cpp    (new)
‚îÇ   ‚îî‚îÄ‚îÄ resourceLocation.hpp    (new - or use existing platformInfo/ResourceLocation.hpp)
‚îÇ
tests/
‚îî‚îÄ‚îÄ resInventory/
    ‚îî‚îÄ‚îÄ test_discoveryScanner.cpp  (new)
```

**Decision on Namespace:** Using `resInventory` to keep with existing ResourceScanner

---

### ResourceLocation Structure

**File:** `src/resInventory/resourceLocation.hpp` (or reuse `platformInfo/ResourceLocation.hpp` if compatible)

```cpp
#ifndef RESOURCELOCATION_HPP
#define RESOURCELOCATION_HPP

#include &lt;QString&gt;
#include "resourceItem.hpp"  // For ResourceTier enum

namespace resInventory {

/**
 * @brief Represents a validated location containing resources
 * 
 * Only created for paths that:
 * 1. Exist on filesystem
 * 2. Are readable
 * 3. Contain at least one resource folder
 * 
 * Per user guidance: "resourceLocation objects are only instantiated when 
 * a given path actually exists and has at least one resource folder in it."
 */
struct ResourceLocation {
    QString path;           ///&lt; Absolute filesystem path
    ResourceTier tier;      ///&lt; Tier this location belongs to
    QString displayName;    ///&lt; Human-readable name for UI
    bool isWritable;        ///&lt; Can user write to this location?
    
    /**
     * @brief Construct a ResourceLocation
     * @param p Absolute path
     * @param t Tier (Installation, Machine, User)
     * @param dn Display name
     * @param w Is writable
     */
    ResourceLocation(const QString& p, ResourceTier t, const QString& dn, bool w)
        : path(p), tier(t), displayName(dn), isWritable(w)
    {}
    
    // Default constructor for Qt containers
    ResourceLocation() : tier(ResourceTier::Unknown), isWritable(false) {}
    
    // Comparison for testing
    bool operator==(const ResourceLocation& other) const {
        return path == other.path && tier == other.tier;
    }
};

} // namespace resInventory

#endif // RESOURCELOCATION_HPP
```

**Rationale:**

- Struct not class (pure data, no invariants)
- Only created for VALID locations (no `exists` boolean needed)
- Simple, testable, clear ownership

---

### DiscoveryScanner Class

**File:** `src/resInventory/discoveryScanner.hpp`

```cpp
#ifndef DISCOVERYSCANNER_HPP
#define DISCOVERYSCANNER_HPP

#include &lt;QString&gt;
#include &lt;QList&gt;
#include "resourceLocation.hpp"
#include "platformInfo/resourcePaths.hpp"  // For PathElement

namespace resInventory {

/**
 * @brief Validates paths and creates ResourceLocation objects
 * 
 * Takes qualified search paths from ResourcePaths and filters to only
 * those that exist, are readable, and contain resource folders.
 * 
 * Per user guidance: Uses QDirIterator for scanning, not QDirListing.
 */
class DiscoveryScanner {
public:
    /**
     * @brief Scan discovery paths and return validated locations
     * 
     * @param discoveryPaths Qualified paths from ResourcePaths::qualifiedSearchPaths()
     * @return List of ResourceLocation objects for valid, populated paths
     * 
     * Validates each path:
     * - Skips empty paths
     * - Checks path exists
     * - Checks path is readable
     * - Checks path contains at least one resource folder
     * - Creates ResourceLocation only if all checks pass
     * 
     * Emits warnings for paths that exist but are inaccessible.
     */
    static QList&lt;ResourceLocation&gt; scanDiscoveryPaths(
        const QList&lt;platformInfo::PathElement&gt;& discoveryPaths);
    
private:
    /**
     * @brief Check if path exists and is accessible
     * @param path Absolute filesystem path
     * @return true if path exists and is readable
     */
    static bool isAccessible(const QString& path);
    
    /**
     * @brief Check if path is writable
     * @param path Absolute filesystem path
     * @return true if user can write to path
     */
    static bool isWritable(const QString& path);
    
    /**
     * @brief Check if path contains any resource folders
     * 
     * Looks for standard resource folder names:
     * - examples/
     * - fonts/
     * - templates/
     * - color-schemes/
     * - libraries/
     * - tests/
     * - locale/
     * - shaders/
     * 
     * @param path Absolute filesystem path
     * @return true if at least one resource folder found
     */
    static bool hasResourceFolders(const QString& path);
    
    /**
     * @brief Generate display name from path and tier
     * 
     * Examples:
     * - Installation tier: "Installation - OpenSCAD"
     * - Machine tier: "Machine - ProgramData"
     * - User tier: "User - Documents" or "User - AppData"
     * 
     * @param path Absolute filesystem path
     * @param tier Resource tier
     * @return Human-readable display name
     */
    static QString generateDisplayName(const QString& path, ResourceTier tier);
    
    /**
     * @brief Get list of expected resource folder names
     * @return List of folder names to check for
     */
    static QStringList resourceFolderNames();
};

} // namespace resInventory

#endif // DISCOVERYSCANNER_HPP
```

---

### DiscoveryScanner Implementation

**File:** `src/resInventory/discoveryScanner.cpp`

```cpp
#include "discoveryScanner.hpp"
#include &lt;QDir&gt;
#include &lt;QFileInfo&gt;
#include &lt;QDebug&gt;

namespace resInventory {

// Static helper: List of resource folder names to check for
QStringList DiscoveryScanner::resourceFolderNames()
{
    return {
        QStringLiteral("examples"),
        QStringLiteral("fonts"),
        QStringLiteral("templates"),
        QStringLiteral("color-schemes"),
        QStringLiteral("libraries"),
        QStringLiteral("tests"),
        QStringLiteral("locale"),
        QStringLiteral("shaders")
    };
}

bool DiscoveryScanner::isAccessible(const QString& path)
{
    if (path.isEmpty()) {
        return false;
    }
    
    QFileInfo info(path);
    return info.exists() && info.isReadable();
}

bool DiscoveryScanner::isWritable(const QString& path)
{
    QFileInfo info(path);
    return info.isWritable();
}

bool DiscoveryScanner::hasResourceFolders(const QString& path)
{
    QDir dir(path);
    if (!dir.exists()) {
        return false;
    }
    
    // Check for any of the expected resource folders
    const QStringList folderNames = resourceFolderNames();
    for (const QString& folderName : folderNames) {
        QString subPath = dir.filePath(folderName);
        QFileInfo info(subPath);
        if (info.exists() && info.isDir()) {
            return true;  // Found at least one resource folder
        }
    }
    
    return false;  // No resource folders found
}

QString DiscoveryScanner::generateDisplayName(const QString& path, ResourceTier tier)
{
    // Get the last component of the path
    QDir dir(path);
    QString lastComponent = dir.dirName();
    
    // Build display name with tier prefix
    QString tierName;
    switch (tier) {
        case ResourceTier::Installation:
            tierName = QStringLiteral("Installation");
            break;
        case ResourceTier::Machine:
            tierName = QStringLiteral("Machine");
            break;
        case ResourceTier::User:
            tierName = QStringLiteral("User");
            break;
        default:
            tierName = QStringLiteral("Unknown");
            break;
    }
    
    // Simplify common paths
    if (lastComponent.isEmpty()) {
        lastComponent = path;  // Use full path if no dir name
    }
    
    // Special handling for Documents, AppData, ProgramData
    if (path.contains(QStringLiteral("Documents"), Qt::CaseInsensitive)) {
        lastComponent = QStringLiteral("Documents");
    } else if (path.contains(QStringLiteral("AppData"), Qt::CaseInsensitive)) {
        lastComponent = QStringLiteral("AppData");
    } else if (path.contains(QStringLiteral("ProgramData"), Qt::CaseInsensitive)) {
        lastComponent = QStringLiteral("ProgramData");
    } else if (path.contains(QStringLiteral("Program Files"), Qt::CaseInsensitive)) {
        // Extract application name from Program Files path
        if (lastComponent == QStringLiteral("Program Files")) {
            lastComponent = QStringLiteral("OpenSCAD");  // Default guess
        }
    }
    
    return QString("%1 - %2").arg(tierName, lastComponent);
}

QList&lt;ResourceLocation&gt; DiscoveryScanner::scanDiscoveryPaths(
    const QList&lt;platformInfo::PathElement&gt;& discoveryPaths)
{
    QList&lt;ResourceLocation&gt; validatedLocations;
    
    for (const auto& pathElement : discoveryPaths) {
        const QString& path = pathElement.path;
        const ResourceTier tier = pathElement.tier;
        
        // Skip empty paths
        if (path.isEmpty()) {
            qDebug() &lt;&lt; "DiscoveryScanner: Skipping empty path";
            continue;
        }
        
        // Check if path exists
        if (!isAccessible(path)) {
            // Path doesn't exist - this is normal, not a warning
            qDebug() &lt;&lt; "DiscoveryScanner: Path does not exist:" &lt;&lt; path;
            continue;
        }
        
        // Check if path contains resource folders
        if (!hasResourceFolders(path)) {
            // Path exists but is empty - warn user
            qDebug() &lt;&lt; "DiscoveryScanner: Path exists but contains no resource folders:" &lt;&lt; path;
            continue;
        }
        
        // Check write access
        bool writable = isWritable(path);
        
        // Generate display name
        QString displayName = generateDisplayName(path, tier);
        
        // Create and add ResourceLocation
        validatedLocations.append(
            ResourceLocation(path, tier, displayName, writable)
        );
        
        qDebug() &lt;&lt; "DiscoveryScanner: Added location:"
                 &lt;&lt; displayName
                 &lt;&lt; "(" &lt;&lt; (writable ? "writable" : "read-only") &lt;&lt; ")";
    }
    
    qDebug() &lt;&lt; "DiscoveryScanner: Found" &lt;&lt; validatedLocations.size()
             &lt;&lt; "validated locations";
    
    return validatedLocations;
}

} // namespace resInventory
```

**Design Rationale:**

1. **Static methods** - No state needed, pure functions
2. **QFileInfo for checks** - Qt-native, platform-independent
3. **QDir for folder checking** - Portable path handling
4. **qDebug for diagnostics** - Console output per user requirement
5. **Early returns** - Clear failure paths
6. **Const references** - Efficient parameter passing

---

## Testing Strategy

### Test File

**File:** `tests/resInventory/test_discoveryScanner.cpp`

```cpp
#include &lt;gtest/gtest.h&gt;
#include &lt;QTemporaryDir&gt;
#include &lt;QDir&gt;
#include &lt;QFile&gt;
#include "resInventory/discoveryScanner.hpp"
#include "platformInfo/resourcePaths.hpp"

using namespace resInventory;
using namespace platformInfo;

/**
 * @brief Test fixture with helper methods
 */
class DiscoveryScannerTest : public ::testing::Test {
protected:
    void SetUp() override {
        m_tempDir = new QTemporaryDir();
        ASSERT_TRUE(m_tempDir-&gt;isValid());
    }
    
    void TearDown() override {
        delete m_tempDir;
    }
    
    /**
     * @brief Create a directory structure
     */
    QString createPath(const QString& relativePath) {
        QString fullPath = m_tempDir-&gt;path() + "/" + relativePath;
        QDir().mkpath(fullPath);
        return fullPath;
    }
    
    /**
     * @brief Create a file
     */
    void createFile(const QString& relativePath, const QString& content = "") {
        QString fullPath = m_tempDir-&gt;path() + "/" + relativePath;
        QFile file(fullPath);
        ASSERT_TRUE(file.open(QIODevice::WriteOnly));
        if (!content.isEmpty()) {
            file.write(content.toUtf8());
        }
        file.close();
    }
    
    QTemporaryDir* m_tempDir;
};

// ============================================================================
// Basic Functionality Tests
// ============================================================================

TEST_F(DiscoveryScannerTest, EmptyInputReturnsEmptyOutput) {
    QList&lt;PathElement&gt; input;
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    EXPECT_TRUE(result.isEmpty());
}

TEST_F(DiscoveryScannerTest, EmptyPathIsSkipped) {
    QList&lt;PathElement&gt; input = {
        {ResourceTier::User, ""}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    EXPECT_TRUE(result.isEmpty());
}

TEST_F(DiscoveryScannerTest, NonExistentPathIsSkipped) {
    QList&lt;PathElement&gt; input = {
        {ResourceTier::Installation, "/this/path/does/not/exist"}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    EXPECT_TRUE(result.isEmpty());
}

TEST_F(DiscoveryScannerTest, PathWithNoResourceFoldersIsSkipped) {
    // Create empty directory
    QString emptyPath = createPath("empty");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::User, emptyPath}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    EXPECT_TRUE(result.isEmpty());
}

// ============================================================================
// Resource Folder Detection Tests
// ============================================================================

TEST_F(DiscoveryScannerTest, PathWithExamplesFolderIsIncluded) {
    QString path = m_tempDir-&gt;path();
    createPath("examples");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::Installation, path}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    ASSERT_EQ(result.size(), 1);
    EXPECT_EQ(result[0].path, path);
    EXPECT_EQ(result[0].tier, ResourceTier::Installation);
}

TEST_F(DiscoveryScannerTest, PathWithFontsFolderIsIncluded) {
    QString path = m_tempDir-&gt;path();
    createPath("fonts");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::Machine, path}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    ASSERT_EQ(result.size(), 1);
    EXPECT_EQ(result[0].tier, ResourceTier::Machine);
}

TEST_F(DiscoveryScannerTest, PathWithTemplatesFolderIsIncluded) {
    QString path = m_tempDir-&gt;path();
    createPath("templates");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::User, path}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    ASSERT_EQ(result.size(), 1);
}

TEST_F(DiscoveryScannerTest, PathWithMultipleResourceFoldersIsIncluded) {
    QString path = m_tempDir-&gt;path();
    createPath("examples");
    createPath("fonts");
    createPath("templates");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::User, path}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    ASSERT_EQ(result.size(), 1);
}

TEST_F(DiscoveryScannerTest, PathWithColorSchemesFolderIsIncluded) {
    QString path = m_tempDir-&gt;path();
    createPath("color-schemes");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::Installation, path}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    ASSERT_EQ(result.size(), 1);
}

// ============================================================================
// Multiple Paths Tests
// ============================================================================

TEST_F(DiscoveryScannerTest, MultipleValidPathsAllIncluded) {
    QString path1 = createPath("location1");
    createPath("location1/examples");
    
    QString path2 = createPath("location2");
    createPath("location2/fonts");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::Installation, path1},
        {ResourceTier::User, path2}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    ASSERT_EQ(result.size(), 2);
}

TEST_F(DiscoveryScannerTest, MixedValidAndInvalidPaths) {
    QString validPath = m_tempDir-&gt;path();
    createPath("examples");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::Installation, "/nonexistent"},
        {ResourceTier::User, validPath},
        {ResourceTier::Machine, ""},
        {ResourceTier::User, "/another/bad/path"}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    ASSERT_EQ(result.size(), 1);
    EXPECT_EQ(result[0].path, validPath);
}

// ============================================================================
// Write Access Tests
// ============================================================================

TEST_F(DiscoveryScannerTest, WritablePathMarkedCorrectly) {
    QString path = m_tempDir-&gt;path();
    createPath("templates");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::User, path}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    ASSERT_EQ(result.size(), 1);
    // Temp directory should be writable
    EXPECT_TRUE(result[0].isWritable);
}

// Note: Testing read-only paths is platform-dependent and complex
// Skipping for now, but could be added with platform-specific code

// ============================================================================
// Display Name Tests
// ============================================================================

TEST_F(DiscoveryScannerTest, DisplayNameIncludesTier) {
    QString path = m_tempDir-&gt;path();
    createPath("examples");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::Installation, path}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    ASSERT_EQ(result.size(), 1);
    EXPECT_TRUE(result[0].displayName.contains("Installation"));
}

TEST_F(DiscoveryScannerTest, UserTierDisplayNameCorrect) {
    QString path = m_tempDir-&gt;path();
    createPath("fonts");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::User, path}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    ASSERT_EQ(result.size(), 1);
    EXPECT_TRUE(result[0].displayName.contains("User"));
}

// ============================================================================
// Edge Cases
// ============================================================================

TEST_F(DiscoveryScannerTest, PathWithOnlyFilesNoFoldersIsSkipped) {
    QString path = m_tempDir-&gt;path();
    createFile("somefile.txt", "content");
    createFile("anotherfile.dat", "more");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::User, path}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    // No resource folders, should be skipped
    EXPECT_TRUE(result.isEmpty());
}

TEST_F(DiscoveryScannerTest, PathWithNonResourceFoldersIsSkipped) {
    QString path = m_tempDir-&gt;path();
    createPath("randomfolder");
    createPath("anotherfolder");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::User, path}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    // No recognized resource folders
    EXPECT_TRUE(result.isEmpty());
}

TEST_F(DiscoveryScannerTest, ResourceFolderAsFileIsIgnored) {
    QString path = m_tempDir-&gt;path();
    // Create "examples" as a file, not a folder
    createFile("examples", "not a folder");
    
    QList&lt;PathElement&gt; input = {
        {ResourceTier::User, path}
    };
    auto result = DiscoveryScanner::scanDiscoveryPaths(input);
    
    // Should be skipped because "examples" is not a directory
    EXPECT_TRUE(result.isEmpty());
}
```

**Test Coverage:**

- ‚úÖ Empty input
- ‚úÖ Empty paths
- ‚úÖ Non-existent paths
- ‚úÖ Paths with no resources
- ‚úÖ Each resource folder type
- ‚úÖ Multiple resource folders
- ‚úÖ Multiple locations
- ‚úÖ Mixed valid/invalid
- ‚úÖ Write access detection
- ‚úÖ Display name generation
- ‚úÖ Edge cases

**Estimated Test Count:** ~20 tests

---

## Integration Example

### How Phase 2A Fits In

```cpp
// In main application or discovery orchestrator

#include "platformInfo/resourcePaths.hpp"
#include "resInventory/discoveryScanner.hpp"

void discoverResources() {
    // Stage 1: Get qualified paths
    platformInfo::ResourcePaths paths;
    QList&lt;platformInfo::PathElement&gt; discoveryPaths = paths.qualifiedSearchPaths();
    
    qDebug() &lt;&lt; "Stage 1: Generated" &lt;&lt; discoveryPaths.size() &lt;&lt; "discovery paths";
    
    // Stage 2: Validate and filter (Phase 2A)
    QList&lt;resInventory::ResourceLocation&gt; locations = 
        resInventory::DiscoveryScanner::scanDiscoveryPaths(discoveryPaths);
    
    qDebug() &lt;&lt; "Stage 2: Found" &lt;&lt; locations.size() &lt;&lt; "valid resource locations";
    
    // Future: Stage 3 (Phase 2B) - LocationScanner will use these locations
    // For now, just report what was found
    for (const auto& loc : locations) {
        qDebug() &lt;&lt; "  -" &lt;&lt; loc.displayName &lt;&lt; ":" &lt;&lt; loc.path;
    }
}
```

---

## Build Integration

### CMakeLists.txt Changes

```cmake
# In src/resInventory/CMakeLists.txt (or main CMakeLists.txt)

# Add new source files
target_sources(resInventory PRIVATE
    discoveryScanner.cpp
    discoveryScanner.hpp
    resourceLocation.hpp  # Header-only if struct
)

# Ensure Qt components are linked
target_link_libraries(resInventory
    Qt6::Core
)

# Add test executable
add_executable(test_discoveryScanner
    ${CMAKE_SOURCE_DIR}/tests/resInventory/test_discoveryScanner.cpp
)

target_link_libraries(test_discoveryScanner
    resInventory
    platformInfo  # For PathElement
    GTest::gtest
    GTest::gtest_main
    Qt6::Core
)

# Register with CTest
add_test(NAME DiscoveryScannerTests COMMAND test_discoveryScanner)
```

---

## Success Criteria

Phase 2A is complete when:

1. ‚úÖ All tests pass (20+ tests)
2. ‚úÖ Code compiles without warnings
3. ‚úÖ Integration with ResourcePaths confirmed
4. ‚úÖ Console output shows expected diagnostics
5. ‚úÖ Manual testing with real filesystem shows correct behavior
6. ‚úÖ Code reviewed and documented

---

## Risks and Mitigations

### Risk 1: Platform Differences

**Problem:** File permissions work differently on Windows vs Unix

**Mitigation:**

- Use Qt's cross-platform `QFileInfo`
- Test on target platform (Windows)
- Document any platform-specific behavior

### Risk 2: Incomplete Resource Folder List

**Problem:** Might miss a resource folder type

**Mitigation:**

- Cross-reference with `Resource-Discovery-Specifications.md`
- Make `resourceFolderNames()` easily extensible
- Add test for each folder type

### Risk 3: Display Name Ambiguity

**Problem:** Multiple paths might generate same display name

**Mitigation:**

- Accept this for Phase 2A (low risk)
- Phase 2B can add disambiguation if needed
- Display names are for UI, not used as keys

---

## Questions for User Review

### Q1: ResourceLocation Placement

Should we:

- **A:** Create new `src/resInventory/resourceLocation.hpp`
- **B:** Reuse existing `src/platformInfo/ResourceLocation.hpp` (if exists)
- **C:** Put struct directly in `discoveryScanner.hpp`

**My Recommendation:** Option A - new file in resInventory namespace

### Q2: Diagnostic Output Level

Current design uses `qDebug()` extensively. Should we:

- **A:** Keep qDebug for now (easy to disable later)
- **B:** Use Qt logging categories (more control)
- **C:** Minimize output (only warnings)

**My Recommendation:** Option A for Phase 2A (simplicity)

### Q3: Empty Resource Folders

If a resource folder exists but is empty (e.g., `examples/` with no files), should we:

- **A:** Include the location (folder exists = valid)
- **B:** Exclude the location (no actual resources)

**My Recommendation:** Option A - DiscoveryScanner only checks folder existence, not contents. Phase 2B will handle empty folders.

---

## Estimated Effort

- **Design:** 2 hours (done)
- **Implementation:** 4 hours
  - discoveryScanner.cpp: 2 hours
  - resourceLocation.hpp: 0.5 hours
  - Integration: 0.5 hours
  - Documentation: 1 hour
- **Testing:** 3 hours
  - Test file creation: 1.5 hours
  - Test execution & debug: 1 hour
  - Manual testing: 0.5 hours
- **Review & Refinement:** 1 hour

**Total:** ~10 hours for Phase 2A

---

## Next Steps After Phase 2A

Once Phase 2A is complete and tested:

1. **Create Phase 2B Design Document**
   - LocationScanner design
   - TypeScanner interfaces
   - Inventory structure decisions (pending Q3/Q4/Q5 from analysis doc)

2. **Break Phase 2B Into Sub-Phases**
   - 2B.1: Template scanning (simplest)
   - 2B.2: Font and color scheme scanning
   - 2B.3: Example scanning with groups
   - 2B.4: Test and library scanning

3. **Maintain Small, Testable Increments**
   - Each sub-phase is independently testable
   - Integration tests after each sub-phase
   - Clear success criteria per sub-phase

---

## Summary

Phase 2A is a **minimal, focused** implementation:

**What It Does:**

- Takes paths, validates them, finds resource folders, creates locations

**What It Doesn't Do:**

- Resource file scanning (Phase 2B)
- Inventory management (Phase 2B)
- GUI integration (Phase 5)

**Why This Scope:**

- Small enough to complete and test thoroughly
- Large enough to provide value (validated locations)
- Clear input/output contract
- Foundation for Phase 2B

**Request for User:** Please review this design and answer questions Q1-Q3. Once approved, I'll begin implementation.

---

## References

- User's revised `2026-01-05-resource-discovery-architecture.md`
- `2026-01-06-revised-discovery-architecture-analysis.md` (questions document)
- [QFileInfo Documentation](https://doc.qt.io/qt-6/qfileinfo.html)
- [QDir Documentation](https://doc.qt.io/qt-6/qdir.html)
- [QTemporaryDir Documentation](https://doc.qt.io/qt-6/qtemporarydir.html)
